All returns are whitespace-delimited.


If the server detects that a request is incomplete (an incomplete HTTP/1.0
request for GET requests, or a truncated request body that doesn't match the
Content-Length header for POST requests), the server will sleep for 30 seconds
before returning 'INCOMPLETE'.  The sleep allows clients to time out and retry
without having to deal with the error message (the server lets them treat
INCOMPLETE requests like server timeouts).  The server only performs this check
for requests that include a account_hmac.



Most calls can return 'DENIED' on failure

Some calls can return 'SHUTDOWN' when the server has been switched into
shutdown mode.  After this, subsequent calls to server may be unsafe in terms
of houses being lost, etc.  Client should stop immediately (and a client that
gets a SHUTDOWN response on startup should stop and tell user to try again
later).  Immediately following the SHUTDOWN response, a plain text message
from the server admin may be included.  Clients can display this message
to the user before shutting down.




=== Call:
server.php?action=check_required_version

Returns:
requiredVersionNumber
newVersionDownloadURL
OK



Where:
requiredVersionNumber is client version number compatible with this server
newVersionDownloadURL is url reminder for users to fetch latest version



=== Call:
server.php?action=check_user&email=[signup email address]
							&sequence_number=[number]
                            &account_hmac=[hmac-sha1, hex-encoded]

Returns:
userID
sequenceNumber
OK

Where:
sequence_number is a dummy sequence number that is not verified to be
as-of-yet unused (can be 0, for example).

account_hmac is the HMAC (see below) computed on sequence_number.
This is not replay-proof, but it doesn't need to be, because it updates no
server state, and userID is not secret. It allows clients to verify their 
account key in one call.

userID = unique user ID number
sequenceNumber = sequence number for hmac-sha1 secure hashing of account keys
                 to sign future transactions.  Any transactions using
                 lower sequence numbers will be denied as stale replays. 


Note:
The idea here is that you pass in a dummy sequece_number just to check if 
your account key is correct, and if it is correct, then the true sequence
number (for your next, fully-validated api call) is returned.




== General Note:
To verify the identity of the user making each transaction, a hash of
that user's account key is included with the transaction call.
That hash is constructed in the following way:

  HMAC_SHA1( account_key, 
             sequence_number . hash_version_number )

Where the two inputs are the ASCII account key (in all caps, with
hyphens removed) and the ASCII, base-10 representation of the sequence number,
and finally concatonated with the ASCII, base-10 representation of the version
number.

Each transaction updates the sequence number associated with the user on
the server.  Each subsequent transaction must use a new sequence number to
thwart replay attacks.

Thus, the account key is never sent from the client to the server, yet the
server can verify that the client making the transaction is indeed in 
possession of the account key (which only one person in the world should have),
as well as the proper version number.






=== Call:
server.php?action=get_sequence_number&user_id=[id number]

Returns:
sequenceNumber
OK





=== Call:
server.php?action=check_hmac&user_id=[id number]
                            &sequence_number=[number]
                            &account_hmac=[hmac-sha1, hex-encoded]
Returns:
OK





=== Call:
server.php?action=get_balance&user_id=[id number]
                             &sequence_number=[number]
                             &account_hmac=[hmac-sha1, hex-encoded]
Returns:
dollar_balance
OK


Where:

dollar_balance is dollars in ASCII floating point





=== Call:
server.php?action=get_deposit_fees

Returns:
flat_fee
percentage
OK

flat_fee is in decimal format as dollars and cents 
(example:  0.30 means 30 cents)

percentage is in decimal format as percentage points
(example:  2.9 means 2.9%)





=== Call:
server.php?action=make_deposit
          &email=[email]
          &client_public_key=[32-byte key, hex-encoded]
          &email_hmac=[hmac-sha1, hex-encoded]
		  &card_data_encrypted=[encrypted card data, hex-encoded]
		  &dollar_amount=[ASCII decimal value]
          &dollar_amount_hmac=[hmac-sha1, hex-encoded]
          &request_tag=[unique string generated by client, hex characters]
       For existing accounts:
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  
		  
Returns:
new_account
encrypted_account_key
OK



Where:

client_public_key  is the client's 32-byte curve25519 public key,
hex-encoded as a 64-character string.

email_hmac is HMAC_SHA1( shared_secret_hex, email ), where shared_secret_hex is
derived through curve25519 key exchange (using the hard-coded 
server_public_key).

card_data_encrypted is the ASCII credit card data in the format
card_number#MM#YYYY#CVC
XOR'd with sufficient bytes from 
HMAC_SHA1( shared_secret_hex, 0 ) . HMAC_SHA1( shared_secret_hex, 1 )
(two HMACs concatonated to make 40 bytes), where shared_secret is derived
through curve25519 key exchange (using the hard-coded server_public_key).
MM and YYYY are the 2- and 4-digit card epiration month and year.
For a 16-digit card number and a 3-digit CVC, the first 28 bytes of the 
40-byte HMAC concatonation are used.

dollar_amount is the ASCII decimal dollar and cents value, with two figures
to the right of the decimal point, like 543.21 or 23.00

dollar_amount_hmac is HMAC_SHA1( shared_secret_hex, dollar_amount ), where 
shared_secret_hex is derived through curve25519 key exchange (using the 
hard-coded server_public_key).

The server can verify this decrypted card data format to thwart
man-in-the-middle attacks from capturing the server response (verifying that 
the client_public_key has not been tampered with---that the person who supplied
a valid, chargeable card number also supplied client_public_key, so it's
safe to send new account details back encrypted against this key).

request_tag is a unique string that the client generates for each new deposit
(to prevent timeouts and retries from resulting in duplicate charges).
The same request_tag should be repeated across retries.

NOTE:
shared_secret_hex, as referenced above, is always UPPERCASE when being
used as a key string for HMAC_SHA1.



Returns DENIED on payment failure.
Returns ACCOUNT_EXISTS if no existing account details were provided and
an account already exists for this email address.
Returns PAYMENT_FAILED if payment fails.


new_account is 1 if no deposit has ever been made for this email address
before.  In this case, an encrypted_account_key is returned for the new
account.  No key is returned if the deposit is made into an existing account
(the string # is returned in that spot instead).

encrypted_account_key is the ASCII representation of the account key, with
hyphens included, XOR'd with sufficient bytes from 
HMAC_SHA1( shared_secret_hex, 2 ) . HMAC_SHA1( shared_secret_hex, 3 )
(two HMACs concatonated to make 40 bytes), where shared_secret is derived
through curve25519 key exchange.
The result is hex encoded.


Deposits into existing accounts MUST include user_id, sequence_number, and
account_hmac.


NOTE:
The only way for someone to obtain their account number directly from the
server is to make an initial deposit for an email address.
A receipt will be emailed to them with their account_key for future reference.

Subsequent deposits must be made using that account key (to generate valid
account_hmacs) and will not return the account_key again.


WEAKNESSES:

An attacker with a valid credit card number can pre-hijack an email address
by making a new account for it and depositing money into it.  The attacker
will then have the account_key for this email address.  However, the email
address owner will receive a receipt by email alerting them that this has
happened.

A man-in-the-middle attack can replace the email address for new account
creation, but only by also replacing the client_public_key, and therefore also
replacing card data with some other, valid card data.  Thus, the attacker
can make deposites into a different, newly-created account, but only by
using the attacker's own card (and not redirecting the target's funds
into a different account).

For existing accounts, an even stronger property holds.





=== Call:
server.php?action=get_withdrawal_methods
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  
		  
Returns:
method_name#dollar_cost
method_name#dollar_cost
method_name#dollar_cost
...
method_name#dollar_cost
OK


Where:
dollar_cost is ascii decimal cost in dollars


Current method_name possibilities include:

us_check
account_transfer




=== Call:
server.php?action=send_us_check
	      &request_sequence_number=[number]
          &request_tag=[unique string generated by client, hex characters]
          &dollar_amount=[dollar amount as 2-decimal float]
          &dollar_amount_hmac=[dollar amount as 2-decimal float]
          &name=[name]
          &name_hmac=[hmac-sha1, hex-encoded]
          &address1=[address line 1]
          &address1_hmac=[hmac-sha1, hex-encoded]
          &address2=[address line 2]
          &address2_hmac=[hmac-sha1, hex-encoded]
          &city=[city name]
          &city_hmac=[hmac-sha1, hex-encoded]
          &state=[two-character state abbreviation]
          &state_hmac=[hmac-sha1, hex-encoded]
          &zip=[zip code]
          &zip_hmac=[hmac-sha1, hex-encoded]
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
OK


Note:
All hmacs (like name_hmac), excluding account_hmac, are computed as

  HMAC_SHA1( account_key . request_sequence_number , 
             url_decoded_string_to_sign )


Where:
request_sequence_number is a unique, ascending sequence number for checks
requested by this account.  These must be increasing, but numbers can be
skipped.  Thus, a copy of sequence_number can be used (though, for the same
request, sequence_number will change during retries, while 
request_sequence_number will not).

request_tag is a unique string that the client generates for each new request
(to prevent timeouts and retries from resulting in duplicate withdrawals).
The same request_tag should be repeated across retries.

name is the check recipient's name, url-encoded.

address1, address2, city, and state are url-encoded. (The unencoded strings
are used for computing the hmacs.)

address2 can be empty (but not omitted), but all other fields must be filled,
or request will be denined.


Returns DENIED on account-level failures (not enough funds, etc).
Returns CHECK_FAILED if request to mail check fails.

Returns OVER_IRS_LIMIT response if the withdrawal cannot be made because
the withdrawal would put the player over the yearly no-reporting (1099-MISC)
limit AND the player's SSN hasn't be collected.  In this case, an email
will be automatically sent to the player with further instructions.






=== Call:
server.php?action=account_transfer
	      &request_sequence_number=[number]
          &request_tag=[unique string generated by client, hex characters]
          &recipient_email=[email]
          &recipient_hmac=[hmac-sha1, hex-encoded]
	      &dollar_amount=[dollar amount as 2-decimal float]
          &dollar_amount_hmac=[hmac-sha1, hex-encoded]
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
OK


Note:
All hmacs (like recipient_hmac), excluding account_hmac, are computed as

  HMAC_SHA1( account_key . request_sequence_number , 
             url_decoded_string_to_sign )


Where:
request_sequence_number serves same function as it does in send_us_check
(a number from the same sequence).

request_tag is a unique string that the client generates for each new request
(to prevent timeouts and retries from resulting in duplicate withdrawals).
The same request_tag should be repeated across retries.


Returns DENIED on account-level failures (not enough funds, etc).
Returns RECIPIENT_NOT_FOUND if no account found for recipient_email.





=== Call:
server.php?action=join_game
	      &request_sequence_number=[number]
          &request_tag=[unique string generated by client, hex characters]
          &dollar_amount=[dollar amount as 2-decimal float]
          &dollar_amount_hmac=[hmac-sha1, hex-encoded]
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
OK


Note:
All hmacs (like dollar_amount_hmac), excluding account_hmac, are computed as

  HMAC_SHA1( account_key . request_sequence_number , 
             url_decoded_string_to_sign )


This call either joins an existing game with dollar_amount, or creates
a new one if none exists.  After this call, wait_game_start should be
used to wait for the game to start.


Where:
game_sequence_number serves same function as it does in send_us_check
(a number from the same sequence).

request_tag is a unique string that the client generates for each new request
(to prevent timeouts and retries from resulting in game creations).
The same request_tag should be repeated across retries.





=== Call:
server.php?action=wait_game_start
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
started
OK

or
waiting
OK

This call is for game creators who are waiting for an opponent to join
their game.




=== Call:
server.php?action=leave_game
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
OK





=== Call:
server.php?action=list_games
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  
		  &skip=[number]
          &limit=[number]

Returns:
dollar_cost
dollar_cost
dollar_cost
dollar_cost
...
dollar_cost
more_pages#skip
OK


Where:
skip is the number of games to skip, in lowest-to-highest cost order, 
when listing games.

limit is the maximum number of games to return


Each returned game has a dollar_cost with 2 fractional digits.

more_pages is 1 if there are more pages of games after this, or 0 if not

skip in the response indicates the skip that was used to generate the list.




=== Call:
server.php?action=get_game_state
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
running
board_layout
your_coins
their_coins
your_pot_coins
their_pot_coins
your_moves
their_moves
OK


Where
running is 0 or 1 (0 if they leave)

board_layout are the 36 numerical squares of the board separated by #

Move lists are a series of up to 6 column or row indices, each in range [0,5]
separated by #.  Empty lists are represented by a single #.

Note that move lists are truncated to show only the amount of moves that
both players have committed so far.  So, if you make a move, and are waiting
for the other player to move, and call get_game_state, your move won't be
included in the response, because the other player hasn't submitted a matching
move yet.





=== Call:
server.php?action=make_move
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  
		  &our_column=[column 0 - 5]
		  &their_column=[column 0 - 5]

Returns:
OK


NOTE:
Moves can only be made after matching bets (or start-of-round buy-ins) have
been made, and only one move can be made per player.

After each pair of moves (from each player, after wait_move returns move_ready
and the move is apparent in the get_game_state result), bets must be made.




=== Call:
server.php?action=wait_move
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  


Returns:

waiting
OK

or
move_ready
OK

or
round_ended
OK

or
opponent_left
OK


This call is for waiting for your opponent to move (or bet).


round_ended expected after calling end_round, once opponent has ended round 
too.

round_ended in the middle of a round, when waiting for a bet from opponent,
means the opponent folded.

In either case, it means the next round has started and will be returned by the
next call to get_game_state.




=== Call:
server.php?action=make_bet
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  
		  &bet=[number of coins to add to pot]

Returns:
OK


NOTE:
Bets can only be made between sets of committed moves from both players.
Bets can be 0, but still must be made using make_bet.

Bets cannot exceed the opponent's non-pot coin balance.

wait_move is used to wait for opponent's bet.

If opponent's bet matches ours, betting is over and the next move must
be made.

If opponent's bet is higher, we must bet again to match it (or bet even
higher), or fold.





=== Call:
server.php?action=fold_bet
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
OK

Instead of matching the opponent's higher bet with make_bet, folds and gives
up on the round, allowing opponent to win all pot coins.

Only possible when opponent has put more coins in the pot than us, where we
would be required to bet more to continue (for example, if opponent bet 0 after
the last move, we cannot call fold_bet). 




=== Call:
server.php?action=end_round
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
OK

After three moves from each player, and interspersed bets, and final bets,
get_game_state returns the final reveal.  After this, both players must call
end_round and then wait_move to wait for their opponent to end_round.

After that, the next call to get_game_state will return the new, starting state
for the next round.




=== Call:
server.php?action=export_check_list
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]


Returns a comma-delimited list of checks that haven't be marked as correctly
exported yet, in this format:

NUM_IN_LIST
"Withdrawal ID","Flag","USD Amount","Email","Name","Addr 1","Addr 2","City","US State","Province","Postal Code", "Country"
"Withdrawal ID","Flag","USD Amount","Email","Name","Addr 1","Addr 2","City","US State","Province","Postal Code", "Country"
"Withdrawal ID","Flag","USD Amount","Email","Name","Addr 1","Addr 2","City","US State","Province","Postal Code", "Country"
...
...
"Withdrawal ID","Flag","USD Amount","Email","Name","Addr 1","Addr 2","City","US State","Province","Postal Code", "Country"
OK


Flag is either "live" for real checks, or "test" for test checks.

Note that this call can be called multiple times (in case of an error) and
potentially return an even longer list of checks each time (if more checks come
in between calls).

However, the last successful call will represent the final list of checks
exported this time.

This call should be followed with a finish_check_export call, once the client 
receives a valid list, to mark those checks as exported.




=== Call:
server.php?action=finish_check_export
          &num_in_export=[number]
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]


Returns:
OK

or:

DENIED



num_in_export should match what was returned from the last successful call to
export_check_list.

Once this call returns OK, those checks are marked as fully exported and
will not be returned by future export_check_list calls.

DENIED will be returned if num_in_export mismatches.