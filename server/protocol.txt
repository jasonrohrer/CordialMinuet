All returns are whitespace-delimited.


If the server detects that a request is incomplete (an incomplete HTTP/1.0
request for GET requests, or a truncated request body that doesn't match the
Content-Length header for POST requests), the server will sleep for 30 seconds
before returning 'INCOMPLETE'.  The sleep allows clients to time out and retry
without having to deal with the error message (the server lets them treat
INCOMPLETE requests like server timeouts).  The server only performs this check
for requests that include a account_hmac.



Most calls can return 'DENIED' on failure

Some calls can return 'SHUTDOWN' when the server has been switched into
shutdown mode.  After this, subsequent calls to server may be unsafe in terms
of houses being lost, etc.  Client should stop immediately (and a client that
gets a SHUTDOWN response on startup should stop and tell user to try again
later).  Immediately following the SHUTDOWN response, a plain text message
from the server admin may be included.  Clients can display this message
to the user before shutting down.




=== Call:
server.php?action=check_required_version

Returns:
requiredVersionNumber
newVersionDownloadURL
OK



Where:
requiredVersionNumber is client version number compatible with this server
newVersionDownloadURL is url reminder for users to fetch latest version



=== Call:
server.php?action=check_user&email=[signup email address]
							&sequence_number=[number]
                            &account_hmac=[hmac-sha1, hex-encoded]

Returns:
userID
sequenceNumber
OK

Where:
sequence_number is a dummy sequence number that is not verified to be
as-of-yet unused (can be 0, for example).

account_zero_hmac is the HMAC (see below) computed on sequence_number.
This is not replay-proof, but it doesn't need to be, because it updates no
server state, and userID is not secret. It allows clients to verify their 
account key in one call.

userID = unique user ID number
sequenceNumber = sequence number for hmac-sha1 secure hashing of account keys
                 to sign future transactions.  Any transactions using
                 lower sequence numbers will be denied as stale replays. 


Note:
The idea here is that you pass in a dummy sequece_number just to check if 
your account key is correct, and if it is correct, then the true sequence
number (for your next, fully-validated api call) is returned.




== General Note:
To verify the identity of the user making each transaction, a hash of
that user's account key is included with the transaction call.
That hash is constructed in the following way:

  HMAC_SHA1( account_key, 
             sequence_number . hash_version_number )

Where the two inputs are the ASCII account key (in all caps, with
hyphens removed) and the ASCII, base-10 representation of the sequence number,
and finally concatonated with the ASCII, base-10 representation of the version
number.

Each transaction updates the sequence number associated with the user on
the server.  Each subsequent transaction must use a new sequence number to
thwart replay attacks.

Thus, the account key is never sent from the client to the server, yet the
server can verify that the client making the transaction is indeed in 
possession of the account key (which only one person in the world should have),
as well as the proper version number.





=== Call:
server.php?action=check_hmac&user_id=[id number]
                            &sequence_number=[number]
                            &account_hmac=[hmac-sha1, hex-encoded]
Returns:
OK





=== Call:
server.php?action=get_balance&user_id=[id number]
                             &sequence_number=[number]
                             &account_hmac=[hmac-sha1, hex-encoded]
Returns:
dollar_balance
OK


Where:

dollar_balance is dollars in ASCII floating point








=== Call:
server.php?action=make_deposit
          &email=[email]
          &client_public_key=[32-byte key, hex-encoded]
          &email_hmac=[hmac-sha1, hex-encoded]
		  &card_data_encrypted=[encrypted card data, hex-encoded]
		  &dollar_amount=[ASCII decimal value]
          &dollar_amount_hmac=[hmac-sha1, hex-encoded]
          &request_tag=[unique string generated by client, hex characters]
       For existing accounts:
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  
		  
Returns:
new_account
encrypted_account_key
OK



Where:

client_public_key  is the client's 32-byte curve25519 public key,
hex-encoded as a 64-character string.

email_hmac is HMAC_SHA1( shared_secret_hex, email ), where shared_secret_hex is
derived through curve25519 key exchange (using the hard-coded 
server_public_key).

card_data_encrypted is the ASCII credit card data in the format
card_number#MM#YYYY#CVC
XOR'd with sufficient bytes from 
HMAC_SHA1( shared_secret_hex, 0 ) . HMAC_SHA1( shared_secret_hex, 1 )
(two HMACs concatonated to make 40 bytes), where shared_secret is derived
through curve25519 key exchange (using the hard-coded server_public_key).
MM and YYYY are the 2- and 4-digit card epiration month and year.
For a 16-digit card number and a 3-digit CVC, the first 28 bytes of the 
40-byte HMAC concatonation are used.

dollar_amount is the ASCII decimal dollar and cents value, with two figures
to the right of the decimal point, like 543.21 or 23.00

dollar_amount_hmac is HMAC_SHA1( shared_secret_hex, dollar_amount ), where 
shared_secret_hex is derived through curve25519 key exchange (using the 
hard-coded server_public_key).

The server can verify this decrypted card data format to thwart
man-in-the-middle attacks from capturing the server response (verifying that 
the client_public_key has not been tampered with---that the person who supplied
a valid, chargeable card number also supplied client_public_key, so it's
safe to send new account details back encrypted against this key).

request_tag is a unique string that the client generates for each new deposit
(to prevent timeouts and retries from resulting in duplicate charges).
The same request_tag should be repeated across retries.

NOTE:
shared_secret_hex, as referenced above, is always UPPERCASE when being
used as a key string for HMAC_SHA1.



Returns DENIED on payment failure.
Returns ACCOUNT_EXISTS if no existing account details were provided and
an account already exists for this email address.
Returns PAYMENT_FAILED if payment fails.


new_account is 1 if no deposit has ever been made for this email address
before.  In this case, an encrypted_account_key is returned for the new
account.  No key is returned if the deposit is made into an existing account
(the string # is returned in that spot instead).

encrypted_account_key is the ASCII representation of the account key, with
hyphens included, XOR'd with sufficient bytes from 
HMAC_SHA1( shared_secret_hex, 2 ) . HMAC_SHA1( shared_secret_hex, 3 )
(two HMACs concatonated to make 40 bytes), where shared_secret is derived
through curve25519 key exchange.
The result is hex encoded.


Deposits into existing accounts MUST include user_id, sequence_number, and
account_hmac.


NOTE:
The only way for someone to obtain their account number directly from the
server is to make an initial deposit for an email address.
A receipt will be emailed to them with their account_key for future reference.

Subsequent deposits must be made using that account key (to generate valid
account_hmacs) and will not return the account_key again.


WEAKNESSES:

An attacker with a valid credit card number can pre-hijack an email address
by making a new account for it and depositing money into it.  The attacker
will then have the account_key for this email address.  However, the email
address owner will receive a receipt by email alerting them that this has
happened.

A man-in-the-middle attack can replace the email address for new account
creation, but only by also replacing the client_public_key, and therefore also
replacing card data with some other, valid card data.  Thus, the attacker
can make deposites into a different, newly-created account, but only by
using the attacker's own card (and not redirecting the target's funds
into a different account).

For existing accounts, an even stronger property holds.





=== Call:
server.php?action=get_withdrawal_methods
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  
		  
Returns:
method_name#dollar_cost
method_name#dollar_cost
method_name#dollar_cost
...
method_name#dollar_cost
OK


Where:
dollar_cost is ascii decimal cost in dollars


Current method_name possibilities include:

us_check
account_transfer




=== Call:
server.php?action=send_us_check
	      &request_sequence_number=[number]
          &request_tag=[unique string generated by client, hex characters]
          &dollar_amount=[dollar amount as 2-decimal float]
          &dollar_amount_hmac=[dollar amount as 2-decimal float]
          &name=[name]
          &name_hmac=[hmac-sha1, hex-encoded]
          &address1=[address line 1]
          &address1_hmac=[hmac-sha1, hex-encoded]
          &address2=[address line 2]
          &address2_hmac=[hmac-sha1, hex-encoded]
          &city=[city name]
          &city_hmac=[hmac-sha1, hex-encoded]
          &state=[two-character state abbreviation]
          &state_hmac=[hmac-sha1, hex-encoded]
          &zip=[zip code]
          &zip_hmac=[hmac-sha1, hex-encoded]
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
OK


Note:
All hmacs (like name_hmac), excluding account_hmac, are computed as

  HMAC_SHA1( account_key . request_sequence_number , 
             url_decoded_string_to_sign )


Where:
request_sequence_number is a unique, ascending sequence number for checks
requested by this account.  These must be increasing, but numbers can be
skipped.  Thus, a copy of sequence_number can be used (though, for the same
request, sequence_number will change during retries, while 
request_sequence_number will not).

request_tag is a unique string that the client generates for each new request
(to prevent timeouts and retries from resulting in duplicate withdrawals).
The same request_tag should be repeated across retries.

name is the check recipient's name, url-encoded.

address1, address2, city, and state are url-encoded. (The unencoded strings
are used for computing the hmacs.)

address2 can be empty (but not omitted), but all other fields must be filled,
or request will be denined.


Returns DENIED on account-level failures (not enough funds, etc).
Returns CHECK_FAILED if request to mail check fails.




=== Call:
server.php?action=account_transfer
	      &request_sequence_number=[number]
          &request_tag=[unique string generated by client, hex characters]
          &recipient_email=[email]
          &recipient_hmac=[hmac-sha1, hex-encoded]
	      &dollar_amount=[dollar amount as 2-decimal float]
          &dollar_amount_hmac=[dollar amount as 2-decimal float]
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
OK


Note:
All hmacs (like recipient_hmac), excluding account_hmac, are computed as

  HMAC_SHA1( account_key . request_sequence_number , 
             url_decoded_string_to_sign )


Where:
request_sequence_number serves same function as it does in send_us_check
(a number from the same sequence).

request_tag is a unique string that the client generates for each new request
(to prevent timeouts and retries from resulting in duplicate withdrawals).
The same request_tag should be repeated across retries.


Returns DENIED on account-level failures (not enough funds, etc).
Returns RECIPIENT_NOT_FOUND if no account found for recipient_email.





=== Call:
server.php?action=create_game
	      &request_sequence_number=[number]
          &request_tag=[unique string generated by client, hex characters]
          &dollar_amount=[dollar amount as 4-decimal float]
          &dollar_amount_hmac=[dollar amount as 2-decimal float]
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
OK


Note:
All hmacs (like dollar_hmac), excluding account_hmac, are computed as

  HMAC_SHA1( account_key . request_sequence_number , 
             url_decoded_string_to_sign )


Where:
game_sequence_number serves same function as it does in send_us_check
(a number from the same sequence).

request_tag is a unique string that the client generates for each new request
(to prevent timeouts and retries from resulting in game creations).
The same request_tag should be repeated across retries.





=== Call:
server.php?action=wait_game_start
          &user_id=[id number]
          &sequence_number=[number]
          &account_hmac=[hmac-sha1, hex-encoded]  

Returns:
started
OK

or
waiting
OK

This call is for game creators who are waiting for an opponent to join
their game.
